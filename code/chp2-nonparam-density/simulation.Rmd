---
title: "Simulation Study for Bandwidth Selectors"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(MASS)
library(reshape2) 
library(tidyverse)
library(ks)
library(rlcv)
```

# simulation here 

```{r warning=FALSE}
# numerical integration to estimate MISE
calculate_mise <- function(true_density, estimated_density, x_values) {
  integrate(splinefun(x_values, (estimated_density - true_density)^2), min(x_values), max(x_values))
}

# True density
bimodal_gaussian <- function(x){
    0.5 * dnorm(x, mean = 0, sd = 1) + 0.5 * dnorm(x, mean = 5, sd = 2)
}
skewed_lognormal <- function(x){
    dlnorm(x, meanlog = 0, sdlog = 1)
}

# Simulation function to calculate MISE for different bandwidth selection methods
simulate_mise <- function(sample_size, num_simulations, true_density) {
  mise <- data.frame(ROT = double(num_simulations), DPI = double(num_simulations),
                     STE = double(num_simulations), LCV = double(num_simulations),
                     LSCV = double(num_simulations)) #UCV = double(num_simulations), 

  for (i in 1:num_simulations) {
    if (true_density == "gaussian") {
      density_func = bimodal_gaussian
      data <- c(rnorm(sample_size / 2, mean = 0, sd = 1), rnorm(sample_size / 2, mean = 5, sd = 2))
    } else if (true_density == "log_normal") {
      density_func = skewed_lognormal
      data <- c(rlnorm(sample_size, meanlog = 0, sdlog = 1))
    }
    
    # Estimating densities using different bandwidth selectors
    bw_rot <- bw.nrd0(data) # normal rule / rule-of-thumb
    bw_dpi <- bw.SJ(data, method = "dpi")  # direct plug-in
    bw_ste <- bw.SJ(data, method = "ste")  # solve the equation
    #bw_ucv <- bw.ucv(data)  # unbiased crossed validation
    bw_lscv <- as.vector(ks::hlscv(data))[1] # least square cross validation
    bw_lcv <- rlcv::lcv(data)[[1]] # likelihood cross validation
    
    x_values <- seq(min(data), max(data), length.out = 1000)
    
    # Calculating the true density values
    true_dens_values <- density_func(x_values)
    
    # KDE for each bandwidth method
    kde_rot <- density(data, bw = bw_rot, from = min(x_values), to = max(x_values), n = length(x_values))
    kde_dpi <- density(data, bw = bw_dpi, from = min(x_values), to = max(x_values), n = length(x_values))
    kde_ste <- density(data, bw = bw_ste, from = min(x_values), to = max(x_values), n = length(x_values))
    #kde_ucv <- density(data, bw = bw_ucv, from = min(x_values), to = max(x_values), n = length(x_values))
    kde_lscv <- density(data, bw = bw_lscv, from = min(x_values), to = max(x_values), n = length(x_values))
    kde_lcv <- density(data, bw = bw_lcv, from = min(x_values), to = max(x_values), n = length(x_values))

    
    # Calculating MISE for each method
    mise$ROT[i] <- calculate_mise(true_dens_values, kde_rot$y, x_values)
    mise$DPI[i] <- calculate_mise(true_dens_values, kde_dpi$y, x_values)
    mise$STE[i] <- calculate_mise(true_dens_values, kde_ste$y, x_values)
    #mise$UCV[i] <- calculate_mise(true_dens_values, kde_ucv$y, x_values)
    mise$LSCV[i] <- calculate_mise(true_dens_values, kde_lscv$y, x_values)
    mise$LCV[i] <- calculate_mise(true_dens_values, kde_lcv$y, x_values)
  }
  
  return(mise)
}

```

```{r}
# carry out simulation which returns the results a list containing ggplot
# objects for illustration
do_simulation <- function(sample_sizes, num_simulations, true_density){
  mise_list <- lapply(sample_sizes, function(n) {
                                      simulate_mise(n, num_simulations, true_density)})
  
  names(mise_list) <- paste("n=", sample_sizes, sep="")
  
  mise_list <- lapply(seq_along(mise_list), function(i) {
  df <- mise_list[[i]]
  df$n <- rep(sample_sizes[i], nrow(df))
  return(df)
  })
  
  mise_data <- do.call(rbind, mise_list)

  for (col in names(mise_data)) {
    if (is.list(mise_data[[col]])) {
      mise_data[[col]] <- unlist(mise_data[[col]])
    }
  }
  
  mise_data_long <- melt(mise_data, id.vars = "n")
  
  mise_data_long$n <- factor(mise_data_long$n)
  levels(mise_data_long$n) <- paste0("n=", levels(mise_data_long$n))
  
  # Plotting MISE boxplots for different sample sizes
  p_MISE <- ggplot(mise_data_long, aes(x = variable, y = value)) +
        geom_boxplot() +
        labs(x = "Bandwidth Selection Method", 
             y = "MISE") +
        facet_wrap(~ n, scales = "free") +
        theme(legend.title = element_blank(),
              panel.grid.major = element_blank(), 
              panel.grid.minor = element_blank(),
              panel.background = element_blank(), 
            axis.line = element_line(colour = "black")) 
  
  
  
  return(list(data = mise_data_long, plot_MISE = p_MISE))
}
```


```{r, warning=FALSE}
sample_sizes <- c(10, 50, 100, 500)
num_simulations <- 100 

result_mixture_Gaussian <- do_simulation(sample_sizes, num_simulations, true_density="gaussian")
#result_log_normal <- do_simulation(sample_sizes, num_simulations, true_density="log_normal")

```

```{r, warning=FALSE}
result_mixture_Gaussian$plot
ggsave("simulation_gaussian_mise.png")

#result_log_normal$plot
#ggsave("simulation_log_normal_mise.png")



```

# comparison of kde with true density. For clarity we only show the case with n=500

```{r}
# should have really done this together with the MISE simulation before

n_sim <- 100 # Number of simulations

# Initialize matrices to store KDE results
kde_rot_matrix <- matrix(NA, nrow = n_sim, ncol = 1000)
kde_dpi_matrix <- matrix(NA, nrow = n_sim, ncol = 1000)
kde_ste_matrix <- matrix(NA, nrow = n_sim, ncol = 1000)
kde_ucv_matrix <- matrix(NA, nrow = n_sim, ncol = 1000)
kde_lcv_matrix <- matrix(NA, nrow = n_sim, ncol = 1000)
kde_lscv_matrix <- matrix(NA, nrow = n_sim, ncol = 1000)


for (i in 1:n_sim) {
  data <- c(rnorm(250, mean = 0, sd = 1), rnorm(250, mean = 5, sd = 2))
  x_values <- seq(min(data), max(data), length.out = 1000)

  # Estimate bandwidths
  bw_rot <- bw.nrd0(data)
  bw_dpi <- bw.SJ(data, method = "dpi")
  bw_ste <- bw.SJ(data, method = "ste")
  bw_ucv <- bw.ucv(data)
  bw_lcv <- rlcv::lcv(data)[[1]]
  bw_lscv <- as.vector(ks::hlscv(data))[1] # least square cross validation


  # KDE calculations for each bandwidth
  kde_rot_matrix[i, ] <- density(data, bw = bw_rot, from = min(x_values), to = max(x_values), n = length(x_values))$y
  kde_dpi_matrix[i, ] <- density(data, bw = bw_dpi, from = min(x_values), to = max(x_values), n = length(x_values))$y
  kde_ste_matrix[i, ] <- density(data, bw = bw_ste, from = min(x_values), to = max(x_values), n = length(x_values))$y
  kde_ucv_matrix[i, ] <- density(data, bw = bw_ucv, from = min(x_values), to = max(x_values), n = length(x_values))$y
  kde_lcv_matrix[i, ] <- density(data, bw = bw_lcv, from = min(x_values), to = max(x_values), n = length(x_values))$y
  kde_lscv_matrix[i, ] <- density(data, bw = bw_lscv, from = min(x_values), to = max(x_values), n = length(x_values))$y

}

# Averaging the KDE values across all simulations
avg_kde_rot <- colMeans(kde_rot_matrix)
avg_kde_dpi <- colMeans(kde_dpi_matrix)
avg_kde_ste <- colMeans(kde_ste_matrix)
avg_kde_ucv <- colMeans(kde_ucv_matrix)
avg_kde_lcv <- colMeans(kde_lcv_matrix)
avg_kde_lscv <- colMeans(kde_lscv_matrix)

df_kdes <- rbind(
  transform(data.frame(x = x_values, y = avg_kde_rot), method = "ROT"),
  transform(data.frame(x = x_values, y = avg_kde_dpi), method = "DPI"),
  transform(data.frame(x = x_values, y = avg_kde_ste), method = "STE"),
  transform(data.frame(x = x_values, y = avg_kde_lcv), method = "LCV"),
  transform(data.frame(x = x_values, y = avg_kde_lcv), method = "LSCV")
)

bimodal_gaussian <- function(x){
    0.5 * dnorm(x, mean = 0, sd = 1) + 0.5 * dnorm(x, mean = 5, sd = 2)
}

ggplot(data.frame(x=x_values, y=bimodal_gaussian(x_values)),aes(x = x, y = y)) +
  geom_line(aes(color = "True Density"), size = 0.8) +
  geom_line(data = df_kdes, aes(x = x, y = y, color = method), linetype = "dashed") +
  scale_color_manual(values = c("True Density" = "black", "ROT" = "blue", "DPI" = "red", "STE" = "green", "LSCV" = "purple", "LCV" = "orange")) +
  labs(x = "Value", y = "Density") +
  theme_minimal() +
  theme(legend.title = element_blank())
```

```{r}
ggsave("simulation_density.png", bg="white") #it defaults to a dark background for some reason

```




